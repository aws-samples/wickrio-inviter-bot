{
  "version": 3,
  "sources": ["../src/util.cjs", "../src/index.cjs"],
  "sourcesContent": ["/**\n * Returns a map of array values and their occurrence count\n *\n * @example\n * countOccurrences([1, 2], [2, 3]); // { 1: 1, 2: 2, 3: 1 }\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {object} Array values and their occurrence count\n */\nfunction countOccurrences(...arrays) {\n    const countObj = {};\n\n    arrays.forEach(array => {\n        array.forEach(v => {\n            countObj[v] = v in countObj ? ++countObj[v] : 1;\n        });\n    });\n\n    return countObj;\n}\n\n/**\n * Returns values found in multiple (possibly all) arrays\n *\n * @example\n * getInMultiple([1, 2], [2, 3]); // [2]\n * getInMultiple([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [2, 3, 4]\n * getInMultiple([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [2, 3, 4, 'x']\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getInMultiple(...arrays) {\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] > 1);\n}\n\n/**\n * Returns values found in all arrays\n *\n * @example\n * getInAll([1, 2], [2, 3]); // [2]\n * getInAll([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [3]\n * getInAll([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [3]\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getInAll(...arrays) {\n    return arrays.reduce((acc, curr) =>\n        acc.filter(Set.prototype.has, new Set(curr))\n    );\n}\n\n/**\n * Returns values found in one array only (i.e. not multiple)\n *\n * @example\n * getNotInMultiple([1, 2], [2, 3]); // [1, 3]\n * getNotInMultiple([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [1, 5]\n * getNotInMultiple([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [1, 5]\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getNotInMultiple(...arrays) {\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] === 1);\n}\n\n/**\n * Returns values not found in all arrays\n *\n * @example\n * getNotInAll([1, 2], [2, 3]); // [1, 3]\n * getNotInAll([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [1, 2, 4, 5]\n * getNotInAll([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [1, 2, 4, 5, 'x']\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getNotInAll(...arrays) {\n    // const vals = new Set(arrays.flat());\n    // const intersection = arrays.reduce((acc, curr) =>\n    //     acc.filter(Set.prototype.has, new Set(curr))\n    // );\n    // const result = [...vals].filter(v => !intersection.includes(v));\n\n    // return result;\n\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] < arrays.length);\n}\n\n/**\n * Determines if the value passed was created using the Object constructor\n *\n * @param {*} obj - Value to test\n * @return {boolean}\n */\nfunction isObject(obj) {\n    return Boolean(obj && obj.constructor.name === 'Object');\n}\n\nmodule.exports = {\n    countOccurrences,\n    getInMultiple,\n    getInAll,\n    getNotInMultiple,\n    getNotInAll,\n    isObject\n};\n", "const {\n    getInMultiple,\n    getInAll,\n    getNotInMultiple,\n    getNotInAll,\n    isObject\n} = require('./util.cjs');\n\nconst defaults = {\n    // Keys\n    onlyKeys: [],\n    skipKeys: [],\n    onlyCommonKeys: false,\n    onlyUniversalKeys: false,\n    skipCommonKeys: false,\n    skipUniversalKeys: false,\n    // Arrays\n    appendArrays: false,\n    prependArrays: false,\n    dedupArrays: false,\n    sortArrays: false,\n    // Callbacks\n    filter: Function.prototype,\n    beforeEach: Function.prototype,\n    afterEach: Function.prototype,\n};\n\nfunction isPropDescriptor(obj) {\n    if (!isObject(obj)) {\n        return false;\n    }\n\n    return (\n        'get' in obj && typeof obj.get === 'function' ||\n        'set' in obj && typeof obj.set === 'function' ||\n        'value' in obj && ('writable' in obj || 'enumerable' in obj || 'configurable' in obj)\n    );\n}\n\n/**\n * Deep recursive object merging with options to inspect, modify, and filter\n * keys/values, merge arrays (append/prepend), and remove duplicate values from\n * merged arrays. Returns new object without modifying sources (immutable).\n *\n * @preserve\n *\n * @example\n * // Without options (use default option values)\n * mergician(obj1, obj2, obj3, ...);\n *\n * @example\n * // With options (defaults shown)\n * mergician({\n *   // Keys\n *   onlyKeys: [],\n *   skipKeys: [],\n *   onlyCommonKeys: false,\n *   onlyUniversalKeys: false,\n *   skipCommonKeys: false,\n *   skipUniversalKeys: false,\n *   // Arrays\n *   appendArrays: false,\n *   prependArrays: false,\n *   dedupArrays: false,\n *   sortArrays: false,\n *   // Callbacks\n *   filter({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n *   beforeEach({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n *   afterEach({ depth, key, mergeVal, srcObj, targetObj }) {},\n * })(obj1, obj2, obj3, ...)\n *\n * @param {...object} optionsOrObjects - Options or objects to merge\n * @param {array} [options.onlyKeys] - Exclusive array of keys to be merged\n * (others are skipped)\n * @param {array} [options.skipKeys] - Array of keys to skip (others are merged)\n * @param {boolean} [options.onlyCommonKeys = false] - Merge only keys found in\n * multiple objects (ignore single occurrence keys)\n * @param {boolean} [options.onlyUniversalKeys = false] - Merge only keys found\n * in all objects\n * @param {boolean} [options.skipCommonKeys = false] - Skip keys found in\n * multiple objects (merge only single occurrence keys)\n * @param {boolean} [options.skipUniversalKeys = false] - Skip keys found in all\n * objects (merge only common keys)\n * @param {boolean} [options.appendArrays = false] - Merge array values at the\n * end of existing arrays\n * @param {boolean} [options.prependArrays = false] - Merge array values at the\n * beginning of existing arrays\n * @param {boolean} [options.dedupArrays = false] - Remove duplicate array\n * values in new merged object\n * @param {boolean|function} [options.sortArrays = false] - Sort array values in\n * new merged object\n * @param {function} [options.filter] - Callback used to conditionally merge or\n * skip a property. Return a \"truthy\" value to merge or a \"falsy\" value to skip.\n * Return no value to proceed according to other option values.\n * @param {function} [options.beforeEach] - Callback used for\n * inspecting/modifying properties before merge. Return value is used as value\n * to merge.\n * @param {function} [options.afterEach] - Callback used for\n * inspecting/modifying properties after merge. Return value is used as merged\n * value.\n * @returns {function|object} Merge function with options applied or new merged\n * object\n * @param {...object} [objects] - Objects to merge\n * @returns {object} New merged object\n */\nfunction mergician(...optionsOrObjects) {\n    const options = arguments.length === 1 ? arguments[0] : {};\n    const settings = { ...defaults, ...options };\n    const dedupArrayMap = new Map();\n    const sortArrayMap = new Map();\n    const sortArrayFn = typeof settings.sortArrays === 'function' ? settings.sortArrays : undefined;\n\n    let mergeDepth = 0;\n\n    function _mergician(...objects) {\n        let mergeKeyList;\n\n        if (objects.length > 1) {\n            if (settings.onlyCommonKeys) {\n                mergeKeyList = getInMultiple(...objects.map(obj => Object.keys(obj)));\n            }\n            else if (settings.onlyUniversalKeys) {\n                mergeKeyList = getInAll(...objects.map(obj => Object.keys(obj)));\n            }\n            else if (settings.skipCommonKeys) {\n                mergeKeyList = getNotInMultiple(...objects.map(obj => Object.keys(obj)));\n            }\n            else if (settings.skipUniversalKeys) {\n                mergeKeyList = getNotInAll(...objects.map(obj => Object.keys(obj)));\n            }\n        }\n\n        if (!mergeKeyList && settings.onlyKeys.length) {\n            mergeKeyList = settings.onlyKeys;\n        }\n\n        if (mergeKeyList && mergeKeyList !== settings.onlyKeys && settings.onlyKeys.length) {\n            mergeKeyList = mergeKeyList.filter(key => settings.onlyKeys.includes(key));\n        }\n\n        const result = objects.reduce((targetObj, srcObj) => {\n            let keys = mergeKeyList || Object.keys(srcObj);\n\n            if (settings.skipKeys.length) {\n                keys = keys.filter(key => settings.skipKeys.indexOf(key) === -1);\n            }\n\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n\n                if (key in srcObj === false) {\n                    continue;\n                }\n\n                const srcVal = srcObj[key];\n                const targetVal = targetObj[key];\n\n                let mergeVal = srcVal;\n\n                if (settings.filter !== defaults.filter) {\n                    const returnVal = settings.filter({\n                        depth: mergeDepth,\n                        key,\n                        srcObj,\n                        srcVal: mergeVal,\n                        targetObj,\n                        targetVal\n                    });\n\n                    if (returnVal !== undefined && !returnVal) {\n                        continue;\n                    }\n                }\n\n                if (settings.beforeEach !== defaults.beforeEach) {\n                    const returnVal = settings.beforeEach({\n                        depth: mergeDepth,\n                        key,\n                        srcObj,\n                        srcVal: mergeVal,\n                        targetObj,\n                        targetVal\n                    });\n\n                    mergeVal = returnVal !== undefined ? returnVal : mergeVal;\n                }\n\n                if (Array.isArray(mergeVal)) {\n                    mergeVal = [...mergeVal];\n\n                    if (Array.isArray(targetVal)) {\n                        if (settings.appendArrays) {\n                            mergeVal = [...targetVal, ...mergeVal];\n                        }\n                        else if (settings.prependArrays) {\n                            mergeVal = [...mergeVal, ...targetVal];\n                        }\n                    }\n\n                    if (settings.dedupArrays) {\n                        // If a user-defined afterEach callback exists, remove\n                        // duplicates so the expected value is returned (slower)\n                        if (settings.afterEach !== defaults.afterEach) {\n                            mergeVal = [...new Set(mergeVal)];\n                        }\n                        // If not, store a reference to the array so duplicates\n                        // can be removed after merge is complete (faster)\n                        else {\n                            const keyArray = dedupArrayMap.get(targetObj);\n\n                            if (keyArray && !keyArray.includes(key)) {\n                                keyArray.push(key);\n                            }\n                            else {\n                                dedupArrayMap.set(targetObj, [key]);\n                            }\n                        }\n                    }\n\n                    if (settings.sortArrays) {\n                        // If a user-defined afterEach callback exists, sort the\n                        // array so the expected value is returned (slower)\n                        if (settings.afterEach !== defaults.afterEach) {\n                            mergeVal = mergeVal.sort(sortArrayFn);\n                        }\n                        // If not, store a reference to the array so duplicates\n                        // can be removed after merge is complete (faster)\n                        else {\n                            const keyArray = sortArrayMap.get(targetObj);\n\n                            if (keyArray && !keyArray.includes(key)) {\n                                keyArray.push(key);\n                            }\n                            else {\n                                sortArrayMap.set(targetObj, [key]);\n                            }\n                        }\n                    }\n                }\n                else if (isObject(mergeVal) && !isPropDescriptor(mergeVal)) {\n                    mergeDepth++;\n\n                    if (isObject(targetVal)) {\n                        mergeVal = _mergician(targetVal, mergeVal);\n                    }\n                    else {\n                        mergeVal = _mergician(mergeVal);\n                    }\n\n                    mergeDepth--;\n                }\n\n                if (settings.afterEach !== defaults.afterEach) {\n                    const returnVal = settings.afterEach({\n                        depth: mergeDepth,\n                        key,\n                        mergeVal,\n                        srcObj,\n                        targetObj\n                    });\n\n                    mergeVal = returnVal !== undefined ? returnVal : mergeVal;\n                }\n\n                // New descriptor returned via callback\n                if (isPropDescriptor(mergeVal)) {\n                    // Defining properties using Object.defineProperty() works\n                    // different than using the assignment operator (obj.a = 1).\n                    // Specifically, the descriptor properties 'configurable',\n                    // 'enumerable', and 'writable' default to 'false' when\n                    // using Object.defineProperty() but to 'true' when using\n                    // the assignment operator. The code below ensures that\n                    // descriptors returned from callbacks are treated as if\n                    // they were assigned using the assignment operator unless\n                    // those properties are explicitly defined in the\n                    // descriptor. This allow merging properties that may\n                    // otherwise fail due to 'configurable' or 'writable' being\n                    // set to 'false'.\n\n                    // Accessor and data descriptor\n                    mergeVal.configurable = !('configurable' in mergeVal) ? true : mergeVal.configurable;\n                    mergeVal.enumerable = !('enumerable' in mergeVal) ? true : mergeVal.enumerable;\n\n                    // Data descriptor\n                    if ('value' in mergeVal && !('writable' in mergeVal)) {\n                        mergeVal.writable = true;\n                    }\n\n                    Object.defineProperty(targetObj, key, mergeVal);\n                }\n                else {\n                    const mergeDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n\n                    // Accessors (getter/setter)\n                    if ('get' in mergeDescriptor) {\n                        Object.defineProperty(targetObj, key, mergeDescriptor);\n                    }\n                    // Standard values\n                    else {\n                        targetObj[key] = mergeVal;\n                    }\n                }\n            }\n\n            return targetObj;\n        }, {});\n\n        // Remove duplicate\n        for (const [obj, keyArray] of dedupArrayMap.entries()) {\n            for (const key of keyArray) {\n                obj[key] = [...new Set(obj[key])];\n            }\n        }\n\n        // Sort arrays\n        for (const [obj, keyArray] of sortArrayMap.entries()) {\n            for (const key of keyArray) {\n                obj[key].sort(sortArrayFn);\n            }\n        }\n\n        return result;\n    }\n\n    // With options\n    // Ex: mergician({...})\n    if (arguments.length === 1) {\n        return function (...objects) {\n            // Options passed to custom merge function\n            if (arguments.length === 1) {\n                return mergician({ ...settings, ...objects[0] });\n            }\n            else {\n                return _mergician(...objects);\n            }\n        };\n    }\n    // Without options\n    // Ex: mergician(obj1, obj2);\n    else {\n        return _mergician(...arguments);\n    }\n}\n\nmodule.exports = mergician;\n"],
  "mappings": "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",
  "names": ["require_util", "__commonJSMin", "exports", "module", "countOccurrences", "arrays", "countObj", "array", "v", "getInMultiple", "getInAll", "acc", "curr", "getNotInMultiple", "getNotInAll", "isObject", "obj", "require_src", "__commonJSMin", "exports", "module", "getInMultiple", "getInAll", "getNotInMultiple", "getNotInAll", "isObject", "defaults", "isPropDescriptor", "obj", "mergician", "optionsOrObjects", "options", "settings", "dedupArrayMap", "sortArrayMap", "sortArrayFn", "mergeDepth", "_mergician", "objects", "mergeKeyList", "key", "result", "targetObj", "srcObj", "keys", "i", "srcVal", "targetVal", "mergeVal", "returnVal", "keyArray", "mergeDescriptor"]
}
